=========================================================================
=========================================================================
=========================== DESIGN PATTERN OOP ==========================
=========================================================================
=========================================================================

I/ Creational Pattern: Nhóm khởi tạo – 5 mẫu gồm: Factory Method, Abstract Factory, Builder, Prototype, Singleton.
	5/ Singleton: Đảm bảo chỉ duy nhất một thể hiện (instance) được tạo ra và nó sẽ cung cấp cho bạn một method để có thể truy xuất được thể hiện duy nhất đó mọi lúc mọi nơi trong chương trình.
	- Ex: 
		<?php
		class Singleton
		{
			private static $instances = [];
		    public static function getInstance()
		    {
		        $cls = static::class;
		        if (!isset(self::$instances[$cls])) {
		            self::$instances[$cls] = new static();
		        }

		        return self::$instances[$cls];
		    }

		    /**
		     * Protected constructor to prevent creating a new instance of the
		     * *Singleton* via the `new` operator from outside of this class.
		     */
		    protected function __construct()
		    {
		    }

		    /**
		     * Private clone method to prevent cloning of the instance of the
		     * *Singleton* instance.
		     *
		     * @return void
		     */
		    private function __clone()
		    {
		    }

		    /**
		     * Private unserialize method to prevent unserializing of the *Singleton*
		     * instance.
		     *
		     * @return void
		     */
		    private function __wakeup()
		    {
		    }
		}

		class SingletonChild extends Singleton
		{
		}

		$obj = Singleton::getInstance();
		var_dump($obj === Singleton::getInstance());             // bool(true)

		$childObj = SingletonChild::getInstance();
		var_dump($childObj === Singleton::getInstance());      // bool(false)

		var_dump($childObj === SingletonChild::getInstance()); // bool(true)


II/ Structural Pattern: Nhóm cấu trúc – 7 mẫu gồm: Adapter, Bridge, Composite, Decorator, Facade, Flyweight và Proxy.
	5/ Facade: Cung cấp class/function có những tính năng đơn giản hơn, để che dấu những tập xử lý phức tạp của nhiều class/function con.
	- Ex:
		class CPU {
		    public void freeze() { ... }
		    public void jump(long position) { ... }
		    public void execute() { ... }
		}

		class HardDrive {
		    public byte[] read(long lba, int size) { ... }
		}

		class Memory {
		    public void load(long position, byte[] data) { ... }
		}

		/* Facade */

		class ComputerFacade {
		    private CPU processor;
		    private Memory ram;
		    private HardDrive hd;

		    public ComputerFacade() {
		        this.processor = new CPU();
		        this.ram = new Memory();
		        this.hd = new HardDrive();
		    }

		    public void start() {
		        processor.freeze();
		        ram.load(BOOT_ADDRESS, hd.read(BOOT_SECTOR, SECTOR_SIZE));
		        processor.jump(BOOT_ADDRESS);
		        processor.execute();
		    }
		}

		/* Client */

		class You {
		    public static void main(String[] args) {
		        ComputerFacade computer = new ComputerFacade();
		        computer.start();
		    }
		}

III/ Behavioral Pattern: Nhóm tương tác/ hành vi – 11 mẫu) gồm: Interpreter, Template Method, Chain of Responsibility, Command, Iterator, Mediator, Memento, Observer, State, Strategy và Visitor.
	1/Strategy: 
	- Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from the clients that use it.
	- Định nghĩa một tập hợp các thuật toán giống nhau, đóng gói chúng và khiến chúng có thể thay thế cho nhau. Strategy làm cho phần thuật toán độc lập khỏi client sử dụng nó.
	=> Khi những hành vi (behavior, method, function) của một đối tượng thay đổi với những thiết lập khác nhau.
	- Ex: class Context, interface StrategyInterface, multi strategy(FirstConcreteStrategy, SecondConcreteStrategy, ...)

		<?php

		interface StrategyInterface {
		    /**
		     * Do something.
		     */
		    public function handle();
		}

		class Context {
		    /**
		     * @var StrategyContract
		     */
		    private $strategy;
		   

		    /**
		     * Context constructor.
		     * 
		     * @param StrategyContract $strategy
		     * @throws Exception
		     */
		    public function __construct(StrategyInterface $strategy)
		    {
		        if (isset($this->strategy)) {
		            throw new Exception("Contract is already present.");
		        }
		        $this->strategy = $strategy;
		    }

		    /**
		     * Call strategy handle() method.
		     */
		    public function handle()
		    {
		        $this->strategy->handle();
		    }
		}

		class FirstConcreteStrategy implements StrategyInterface {
		    
		    /**
		     * {@inheritdoc}
		     */
		    public function handle()
		    {
		        echo PHP_EOL . 'DOING SOMETHING' . PHP_EOL;
		    }
		}

		class SecondConcreteStrategy implements StrategyInterface {
		    
		    /**
		     * {@inheritdoc}
		     */
		    public function handle() {
		        echo PHP_EOL . 'DOING SOMETHING SLIGHT DIFFERENTLY' . PHP_EOL;
		    }
		}

		//
		$context = new Context(new FirstConcreteStrategy());
		$context->handle();

		$second_context = new Context(new SecondConcreteStrategy());
		$second_context->handle();

IV/ Other Pattern
1/ Repository
	- Là tầng trung gian giữa business logic và data access
	- Ex:
		+ Provider config:
			'providers' => [
			...
			    App\Providers\RepositoryServiceProvider::class,
			],

		+ New provider service
			use App\Contracts\Repositories\PropductRepositoryInterface;
			use App\Repositories\ProductRepository;

			public function register()
			{
			   $this->app->bind(ProductRepositoryInterface::class, ProductRepository::class);
			}

		+ Controller:
			namespace App\Http\Controllers;
			use ProductRepositoryInterface;

			class ProductController extends Controller
			{    
				protected $productRepository;

				public function __construct(ProductRepositoryInterface $productRepository)
				{
					$this->productRepository = $productRepository;
				}

				public function getProduct()
				{
					$products = $this->productRepository->getProductOrderById();
					return view('product.index', compact('products'));
				}
			}

		+ Repository
			namespace App\Repositories;
​
			use App\Models\Product;
			​
			class ProductRepository implements ProductRepositoryInterface
			{
			{
			    //override
			    public function getProductOrderById()
			    {
			        return Product::orderBy('id', 'desc')->get();
			    }
			}

		+ Base interface
			namespace App\Contracts\Repositories;

			interface BaseRepositoryInterface
			{
			    public function model();
			    public function getAll();
			    public function create(array $data);
			    public function show(int $id);
			    public function edit(int $id);
			    public function delete(int $id);
			    ....
			}

		+ interface
			namespace App\Contracts\Repositories;

			interface ProductRepositoryInterface extends BaseRepositoryInterface
			{
			    public function getFulfilledProduct(int $productId);
			    public function getProductTags(int $productId);
			    .....
			}